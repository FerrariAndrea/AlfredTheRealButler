/* Generated by AN DISI Unibo */ 
package it.unibo.onerotateforward

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Onerotateforward ( name: String, scope: CoroutineScope ) : ActorBasicFsm( name, scope){
 	
	override fun getInitialState() : String{
		return "s0"
	}
		
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
				val RotateTime = 1L
				val CompleteRotateTimeA = 400L
				val CompleteRotateTimeD = 450L
				val ErroreConcesso : Int = 2
				val SogliaDiScarto : Int = 20 //per evitare errori dovuti ad esempio al tavolo in mezzo alla stanza
				val WaitingTimg : Long = 5000
				//------------------------
				var RealMove = "a" 
				//for calibration:
				var SonarD :Int =-1
				var SonarA :Int =-1
				var SonarW :Int =-1
				var SonarDAfter :Int =-1
				var SonarAAfter :Int =-1
				var SonarWAfter :Int =-1
				var Arotate = false
				var NeedCalibration = true
				var NeedCorrezione =false
				//-----------FIX rotation
				val FixEnable = false
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						println("Start onerotateforward")
					}
					 transition( edgeName="goto",targetState="ready", cond=doswitch() )
				}	 
				state("ready") { //this:State
					action { //it:State
						println("onerotateforward is READY")
					}
					 transition(edgeName="t016",targetState="checkFirst",cond=whenDispatch("onerotationstep"))
					transition(edgeName="t017",targetState="paused",cond=whenDispatch("stop"))
				}	 
				state("paused") { //this:State
					action { //it:State
						println("onerotateforward is PAUSED")
					}
					 transition(edgeName="t018",targetState="ready",cond=whenDispatch("reactivate"))
				}	 
				state("checkFirst") { //this:State
					action { //it:State
						storeCurrentMessageForReply()
						if( checkMsgContent( Term.createTerm("onerotationstep(MOVE)"), Term.createTerm("onerotationstep(ORIENTATION)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								RealMove = payloadArg(0)
								if(RealMove=="a" ||  RealMove=="d"){ SonarD=-1;SonarA=-1;SonarW=-1;
								 }
						}
					}
					 transition(edgeName="t119",targetState="calibration",cond=whenEvent("sonarRobot"))
					transition(edgeName="t120",targetState="calibration",cond=whenEvent("sonarLeft"))
					transition(edgeName="t121",targetState="calibration",cond=whenEvent("sonarRight"))
				}	 
				state("calibration") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("sonar(DISTANCE)"), Term.createTerm("sonar(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								SonarW=Integer.parseInt( payloadArg(0) )
						}
						if( checkMsgContent( Term.createTerm("sonar(DISTANCE)"), Term.createTerm("sonar(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								SonarA=Integer.parseInt( payloadArg(0) )
						}
						if( checkMsgContent( Term.createTerm("sonarRight(DISTANCE)"), Term.createTerm("sonarRight(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								SonarD=Integer.parseInt( payloadArg(0) )
						}
						NeedCalibration=(SonarD<0 || SonarA<0 || SonarW<0)
					}
					 transition( edgeName="goto",targetState="calibrationAgaint", cond=doswitchGuarded({NeedCalibration}) )
					transition( edgeName="goto",targetState="doRotationForward", cond=doswitchGuarded({! NeedCalibration}) )
				}	 
				state("calibrationAgaint") { //this:State
					action { //it:State
					}
					 transition(edgeName="t122",targetState="calibration",cond=whenEvent("sonarRobot"))
					transition(edgeName="t123",targetState="calibration",cond=whenEvent("sonarLeft"))
					transition(edgeName="t124",targetState="calibration",cond=whenEvent("sonarRight"))
				}	 
				state("doRotationForward") { //this:State
					action { //it:State
						delay(80) 
						if(RealMove=="a"){ forward("internalRobotReq", "internalRobotReq(as,1,$CompleteRotateTimeA,0)" ,"basicrobot" ) 
						forward("modelUpdate", "modelUpdate(robot,a)" ,"resourcemodel" ) 
						 }
						if(RealMove=="d"){ forward("internalRobotReq", "internalRobotReq(ds,1,$CompleteRotateTimeD,0)" ,"basicrobot" ) 
						forward("modelUpdate", "modelUpdate(robot,d)" ,"resourcemodel" ) 
						 }
					}
					 transition(edgeName="t125",targetState="endRotate",cond=whenEvent("internalRobotRes"))
				}	 
				state("endRotate") { //this:State
					action { //it:State
						forward("modelUpdate", "modelUpdate(robot,h)" ,"resourcemodel" ) 
						if(!FixEnable){ if(RealMove=="a"){ forward("modelUpdate", "modelUpdate(robot,a)" ,"kb" ) 
						 }
						if(RealMove=="d"){ forward("modelUpdate", "modelUpdate(robot,d)" ,"kb" ) 
						 }
						replyToCaller("rotationOk", "rotationOk(0)")
						 }
					}
					 transition( edgeName="goto",targetState="startFix", cond=doswitchGuarded({FixEnable}) )
					transition( edgeName="goto",targetState="ready", cond=doswitchGuarded({! FixEnable}) )
				}	 
				state("startFix") { //this:State
					action { //it:State
						delay(WaitingTimg)
						SonarDAfter=-1;SonarAAfter=-1;SonarWAfter-1;
					}
					 transition(edgeName="t126",targetState="calibrationAfter",cond=whenEvent("sonarRobot"))
					transition(edgeName="t127",targetState="calibrationAfter",cond=whenEvent("sonarLeft"))
					transition(edgeName="t128",targetState="calibrationAfter",cond=whenEvent("sonarRight"))
				}	 
				state("calibrationAfter") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("sonar(DISTANCE)"), Term.createTerm("sonar(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								SonarWAfter=Integer.parseInt( payloadArg(0) )
						}
						if( checkMsgContent( Term.createTerm("sonar(DISTANCE)"), Term.createTerm("sonar(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								SonarAAfter=Integer.parseInt( payloadArg(0) )
						}
						if( checkMsgContent( Term.createTerm("sonarRight(DISTANCE)"), Term.createTerm("sonarRight(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								SonarDAfter=Integer.parseInt( payloadArg(0) )
						}
						NeedCalibration=(SonarDAfter<0 || SonarAAfter<0 || SonarWAfter<0)
					}
					 transition( edgeName="goto",targetState="calibrationAfterAgaint", cond=doswitchGuarded({NeedCalibration}) )
					transition( edgeName="goto",targetState="correggi", cond=doswitchGuarded({! NeedCalibration}) )
				}	 
				state("calibrationAfterAgaint") { //this:State
					action { //it:State
					}
					 transition(edgeName="t129",targetState="calibrationAfter",cond=whenEvent("sonarRobot"))
					transition(edgeName="t130",targetState="calibrationAfter",cond=whenEvent("sonarLeft"))
					transition(edgeName="t131",targetState="calibrationAfter",cond=whenEvent("sonarRight"))
				}	 
				state("correggi") { //this:State
					action { //it:State
						NeedCorrezione =false
						if(RealMove=="d"){ Arotate=false;NeedCorrezione=(Math.abs(SonarD-SonarWAfter)>ErroreConcesso ||  Math.abs(SonarW-SonarAAfter)>ErroreConcesso )
						 }
						else
						 { if(RealMove=="a"){ Arotate=true;NeedCorrezione=(Math.abs(SonarA-SonarWAfter)>ErroreConcesso ||  Math.abs(SonarW-SonarDAfter)>ErroreConcesso )
						  }
						 else
						  { 
						  					var differenceA =SonarAAfter-SonarA
						  					var differenceD =SonarDAfter-SonarD
						  if((Math.abs(differenceA)>ErroreConcesso*2 && Math.abs(differenceA)<SogliaDiScarto)){ NeedCorrezione=true
						  Arotate=differenceA>0
						   }
						  if((Math.abs(differenceD)>ErroreConcesso*2 && Math.abs(differenceD)<SogliaDiScarto)){ NeedCorrezione=true
						  Arotate=differenceD<0
						   }
						   }
						  }
					}
					 transition( edgeName="goto",targetState="miniRotate", cond=doswitchGuarded({NeedCorrezione}) )
					transition( edgeName="goto",targetState="endDoRotationForward", cond=doswitchGuarded({! NeedCorrezione}) )
				}	 
				state("miniRotate") { //this:State
					action { //it:State
						delay(50) 
						if(Arotate){ forward("internalRobotReq", "internalRobotReq(am,1,2,0)" ,"basicrobot" ) 
						 }
						else
						 { forward("internalRobotReq", "internalRobotReq(dm,1,2,0)" ,"basicrobot" ) 
						  }
					}
					 transition(edgeName="t132",targetState="endMiniRotate",cond=whenEvent("internalRobotRes"))
				}	 
				state("endMiniRotate") { //this:State
					action { //it:State
						forward("modelUpdate", "modelUpdate(robot,h)" ,"resourcemodel" ) 
						delay(WaitingTimg)
						SonarDAfter=-1;SonarAAfter=-1;SonarWAfter-1;
					}
					 transition(edgeName="t133",targetState="calibrationAfter",cond=whenEvent("sonarRobot"))
					transition(edgeName="t134",targetState="calibrationAfter",cond=whenEvent("sonarLeft"))
					transition(edgeName="t135",targetState="calibrationAfter",cond=whenEvent("sonarRight"))
				}	 
				state("endDoRotationForward") { //this:State
					action { //it:State
						if(RealMove=="a"){ forward("modelUpdate", "modelUpdate(robot,a)" ,"kb" ) 
						 }
						if(RealMove=="d"){ forward("modelUpdate", "modelUpdate(robot,d)" ,"kb" ) 
						 }
						delay(50) 
						replyToCaller("rotationOk", "rotationOk(0)")
					}
					 transition( edgeName="goto",targetState="ready", cond=doswitch() )
				}	 
			}
		}
}
