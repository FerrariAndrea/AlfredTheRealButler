System system3
mqttBroker "localhost" : 1883

Dispatch modelChange  : modelChange( TARGET, VALUE )  //force a resource-model change
Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time
Dispatch onerotationstep   : onerotationstep(MOVE)
Dispatch rotationOk        : rotationOk(STALL)

Dispatch goTo  : goTo( X,Y )
Dispatch testCmd: testCmd(cmd)

//Macro dispatch
Dispatch addFood : addFood(X) //1 or 2: payload for now is ignored.
Dispatch prepare : prepare()
Dispatch clear : clear()

Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 

Context ctxExplorer ip[host="localhost" port=8039] -mqtt
Context ctxDummy ip[host="dummyhost" port=9999] -mqtt 

ExternalQActor maitre context ctxDummy
ExternalQActor resourcemodel context ctxDummy
ExternalQActor onecellforward context ctxDummy
ExternalQActor onerotateforward context ctxDummy

/*
 *  The goal is to move the robot to the fridge and let it come back 
 *  Fridge Position is given *a priori*
 */

QActor explorer context ctxExplorer{     
	["
	var fridge_position_x = 6;
	var fridge_position_y = 0;
	var goingHome  = false
	var stepCounter = 0 
	var Move = \"\"
	var StepTime   = 350L	//for virtual
	var RotateTime = 300L	//for virtual
	var PauseTime  = 250L 
	var Direction = \"\"
	var RepeatAction = 1
	var addingFood = false
	var preparing = false
	var clearing = false
	"]	
	State s0 initial {	
		println("Actor: Explorer; State: initial")
	    solve( consult("moves.pl")	 )
		run itunibo.planner.plannerUtil.initAI()
		println("Actor: Explorer; State: handleStepFail; Payload: INITIAL MAP")
 		run itunibo.planner.plannerUtil.showMap()
 	} Goto readyForAction
 	
 	State readyForAction {
 		println("Waiting for mission... Please send an action!")
 	} 	
	Transition t0 whenEvent   goTo  -> goToPosition
				  whenEvent	  addFood -> addingFood
				  whenEvent   prepare -> preparingRoom
				  whenEvent   prepare -> clearingRoom
				  //qui handleStop -> stopped
	
	State addingFood {
		//SI DEVE AGGIUNGERE IL PAYLOAD, OVVERO SE SI AGGIUNGE IL TIPO 1 DI CIBO (PIZZA) OPPURE IL TIPO 2 (CRESCENTINA)
		//COSA FA QUESTO TASK?
		//SE IL CIBO E' PRESENTE NEL FRIGO, LO AGGIUNGE AL TAVOLO; IN CASO CONTRARIO, NOTIFICA IL MAITRE
		//RITORNA NELLA POSIZIONE HOME
		println("ADDING FOOD: Go to Fridge")
		["addingFood = true"]
	} Goto goToFridge
	
	State preparingRoom {
		//METTERE PIATTI DAL PANTRY AL TABLE
	}
	
	State clearingRoom {
		//PRENDERE CIBO DAL TAVOLO, PORTARLO AL FRIGO E I PIATTI NEL DISHWASHER
	}
	
	State goToFridge {
		solve( direction(D) )   
   		println("Actor: Explorer; State: goToFridge; Payload: direction at start: ${getCurSol(\"D\").toString()}")
		run itunibo.planner.plannerUtil.showMap()		
		run itunibo.planner.plannerUtil.setGoal(5,0)
		["goingHome=false"]	
		run itunibo.planner.moveUtils.doPlan( myself )
	}
	
	Goto executePlannedActions  if "itunibo.planner.moveUtils.existPlan()" else endOfJob 
	
	State stopped{
		//waiting
	}//Transition t0  whenEvent   Resume  -> readyForAction
	
	
	State goToPosition{
	 	
	 	onMsg(   goTo:  goTo(X,Y) ) { 
			
			["
				var X = payloadArg(0).toInt()
				var Y = payloadArg(1).toInt()
				//var O = payloadArg(2)
			"]
				
		solve( direction(D) )   
   		println("Actor: Explorer; State: goToPosition; Payload: direction at start: ${getCurSol(\"D\").toString()}")
		run itunibo.planner.plannerUtil.showMap()		
		run itunibo.planner.plannerUtil.setGoal(X,Y)
		["goingHome=false"]	
		run itunibo.planner.moveUtils.doPlan( myself )
		}
 	} 	
  		
	Goto executePlannedActions  if "itunibo.planner.moveUtils.existPlan()" else endOfJob 
	
	State executePlannedActions{ 
		//solve( showMoves ) 
		solve( retract( move(M) ) ) //consume a move
		ifSolved {  
			["Move = getCurSol(\"M\").toString()"]
		} else { ["Move = \"\""]  }  
 	}
	Goto doTheMove  if "(Move.length>0) " else goalOk 
 	
 	State goalOk{		  
 		println("Explorer: on the target cell!")
 	} //Goto atHome if "goingHome" else goHome
 	Goto goToTable if "addingFood" else checkIfGoingHome
 	
 	State checkIfGoingHome {
 	}
 	Goto atHome if "goingHome" else goHome
 	
 	State goToTable {
 		solve( direction(D) )   
   		println("Actor: Explorer; State: goToTable; Payload: direction at start: ${getCurSol(\"D\").toString()}")
		run itunibo.planner.plannerUtil.showMap()
		
		run itunibo.planner.plannerUtil.setGoal(5,4)
		["addingFood=false"]
		run itunibo.planner.moveUtils.doPlan( myself )
 	} 	Goto executePlannedActions  if "itunibo.planner.moveUtils.existPlan()" else endOfJob 
 	
	State doTheMove{
		if "Move==\"a\" || Move==\"d\" " {//ROTATION			
			forward onerotateforward -m onerotationstep : onerotationstep($Move)	
		} else{ // W			
			forward onecellforward -m onestep : onestep($StepTime)	
		}	
	}
	Transition t0   whenMsg stepOk   	-> handleStepOk   
					whenMsg stepFail 	-> handleStepFail  
					whenMsg rotationOk 	-> handleStepOk
					//qui handleStop
	 	
	State handleStepOk{
		run itunibo.planner.moveUtils.doPlannedMove(myself, Move)	
		delayVar PauseTime	
	}
	Goto executePlannedActions
	
	State handleStepFail{ 
		println("Actor: Explorer; State: handleStepFail; Payload: Fail step :(")
		run itunibo.planner.plannerUtil.showMap()	
		println("Actor: Explorer; State: handleStepFail; Payload: Replan and return at home.")
		delay 500
	}	
 	Goto goHome
 	
/*
 * Exploration step done: go back to home
 * If we use the planner - setGoal(0,0) - then the robot could 
 * find an obstacle in the return path
 */	 
	 
	State goHome{
		println("Actor: Explorer; State: backToHome")
 		solve( direction(D) )
   		println("Actor: Explorer; State: backToHome; Payload: ${getCurSol(\"D\").toString()}")
 		println("Actor: Explorer; State: backToHome; Payload: MAP BEFORE backToHome")
		run itunibo.planner.plannerUtil.showMap()	
		solve( retractall( move(_) ))		//clean the actor kb
 		run itunibo.planner.plannerUtil.setGoal(0,0)
 		["goingHome=true"]
 		run itunibo.planner.moveUtils.doPlan( myself )
 		run itunibo.planner.moveUtils.existPlan() //is it necessary?
 	} 
	Goto executePlannedActions //doGoHomeActions 
	
	State atHome {  //reposition	
 		solve( direction(D) )
 		["Direction = getCurSol(\"D\").toString() "]
		println( @D ) 
		["
		val map = itunibo.planner.plannerUtil.getMap() 
		println(map)
		"] 		
   		println("Actor: Explorer; State: atHome; Payload: direction at home: ${getCurSol(\"D\").toString()}")
   	
	}
	Goto rotateSouth
	
	State rotateSouth{
		["Move=\"a\""]
		delayVar StepTime
		forward onerotateforward -m onerotationstep : onerotationstep($Move)//
   		
	}Transition t0	whenMsg rotationOk 	-> checkSouth

	State checkSouth{
		run itunibo.planner.moveUtils.doPlannedMove(myself, Move)	
		solve( direction(D) )
		["Direction = getCurSol(\"D\").toString() "]
		println("Actor: Explorer; State: rotateSouth; Payload: $Direction")
	}
	Goto rotateSouth  if "(Direction!=\"downDir\")" else endOfJob
	
	State endOfJob{
		println("Explorer: EndOfJob, go to ReadyForAction")
	} Goto readyForAction if "(RepeatAction > 0)" else end
	
	State end {
		println("Explorer: END")
	}
}	
