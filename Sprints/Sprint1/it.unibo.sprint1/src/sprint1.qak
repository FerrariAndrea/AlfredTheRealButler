/*
 * Sprint1 (TestPlan1)
 * 
 * Muove il robot virtuale
 * Usa il planner con mappa statica per trovare la strada verso il frigo e tronare indietro
*/
System sprint1
mqttBroker "localhost" : 1883  


Dispatch modelChange  : modelChange( TARGET, VALUE )   
Dispatch robotCmd     : robotCmd( CMD )				  //sent by the mind to the basicrobot

Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Dispatch modelChange  : modelChange( TARGET, VALUE )  //force a resource-model change
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )  //sent by the mind
 
Dispatch askPlan  : askPlan(X,Y) 
  
 
Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 
Event  obstacle       : obstacle( DISTANCE )	     //from  sonar handler

Event  local_modelChanged   : modelChanged( TARGET, VALUE )

Context ctxMindSprint1   ip [host="localhost" port=8038]    -mqtt 


/*
 * resourcemodel viene modificato e di conseguenza BasicRobot
 */
//ExternalQActor resourcemodel context ctxMindSprint1
QActor butler context ctxMindSprint1{
	["
		var BackTime   = 500L		
		var StepTime   = 330L	//for virtual
		var RotateTime = 300L	//for virtual
		var PauseTime  = 100L 
		var dest_x =7;
		var dest_y =0;
	"]	
		State s0 initial {	
		println("&&&  butler STARTED")
		solve( consult("sysRules.pl")	 )       
		solve( consult("floorMap.pl")	 )
		solve( showMap	 )
 	}Goto exploreTheRoom
	
	State exploreTheRoom{
		
	}
	Goto testPlan0
	
	State testPlan0{ 
		
		forward butlerstep -m onestep : onestep( $StepTime )
 	}
	
	State testPlan1{ 
		//questo lo chiediamo al prof, c'è un errore nei qak:
		//forward planner -m askPlan : askPlan("$dest_x" ,"$dest_y")
		//per ora facciamo così
		forward planner -m askPlan : askPlan(7,0)
		
 	}
	//Transition t0   whenMsg stepOk   -> hadleStepOk
	//				whenMsg stepFail -> hadleStepKo 
}

/*
 * 1) Waits for the message 'onestep' from the application layer
 * 2) Performs a single-step-ahead with the given time
 * 3) If all ok, sends the 'answer'  stepOk
 * 4) If finds an obstacle, sends the 'answer' stepFail(T) with T=time elapsed before obstacle
 */
 
QActor butlerstep context ctxMindSprint1 {
[" var foundObstacle = false; var StepTime = 0L"]  
	State s0 initial {	   
		["foundObstacle = false "]
	} 
	Transition t0 whenMsg onestep -> doMoveForward
	
	State doMoveForward{		  
		onMsg( onestep : onestep( TIME ) ) { 
			["StepTime = payloadArg(0).toLong(); println(StepTime)"]
			forward resourcemodel -m modelChange : modelChange(robot,w)
			run itunibo.planner.plannerUtil.startTimer()
		}
	} 
	Transition t0 whenTimeVar  StepTime   -> endDoMoveForward		
 		          whenEvent     obstacle  -> stepFail
		  
	State endDoMoveForward{
		forward resourcemodel -m modelChange : modelChange(robot,h)
		forward butler -m stepOk : stepOk(ok)  //answer
	}
	Goto s0
		
	State stepFail{
		run itunibo.planner.moveUtils.setDuration(myself)  //assert wduration/1
		println("&&& butlerstep stepfail ")
		solve( wduration( TIME ) )
		forward butler -m stepFail : stepFail(obstacle,#TIME)  	
	}
	Goto s0


}   


QActor planner context ctxMindSprint1{      
["  
var Curmove     = \"\"  
var IterCounter = 0
"]	
	State s0 initial {	 
		println("&&&  planex0 STARTED")
		run itunibo.planner.plannerUtil.initAI()
		println("INITIAL MAP") 
 		run itunibo.planner.plannerUtil.showMap() 
 	}
  	Transition t0 whenEvent  askPlan -> setGoal
  	
 	State setGoal{
 		onMsg( askPlan : askPlan( X,Y ) ) { 
 			["
				var x = payloadArg(0)
 				var y = payloadArg(1)
			"]
 			run itunibo.planner.plannerUtil.setGoal(x,y)
 		 	run itunibo.planner.moveUtils.doPlan( myself ) //moves stored in actor kb
	 	}
 	}Goto executePlannedActions  
     
    State executePlannedActions{ 
 		solve( retract( move(M) ) ) 	//consume a move
		ifSolved {   
			["Curmove = getCurSol(\"M\").toString()"]  
			run itunibo.planner.moveUtils.doPlannedMove(myself, Curmove)
			//muovo il robot verso il frigo
			run itunibo.planner.plannerUtil.executeMoves()			
 			run itunibo.planner.plannerUtil.showMap() 
		} else { ["Curmove=\"nomove\" "] 		} 
 
  	}  
	Goto executePlannedActions  if "(Curmove != \"nomove\")" else goBack
 
 	
  	State goBack{
  		//torno indietro
  		run itunibo.planner.plannerUtil.setGoal("0","0")    
  		run itunibo.planner.moveUtils.doPlan( myself ) 
  		run itunibo.planner.plannerUtil.executeMoves()			
 		run itunibo.planner.plannerUtil.showMap() 
 		println("------------------>    ENDS")
  	}
 
}	

 

QActor resourcemodel context ctxMindSprint1{
["var dobackstep = false"]
	State s0 initial {		
		solve( consult("sysRules.pl")	 )       
		solve( consult("resourceModel.pl")	 )
		solve( showResourceModel ) 		
		run itunibo.coap.modelResourceCoap.create( myself, "resourcemodel" ) //CoAP access
	} 
	Goto waitModelChange
	 
	State waitModelChange{ }
	Transition t0 whenMsg modelChange -> changeModel
	              whenMsg modelUpdate -> updateModel

	State updateModel{  
		onMsg( modelUpdate : modelUpdate(robot,V ) ) {
			run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
		}
		onMsg( modelUpdate : modelUpdate(sonarRobot,V ) ) {
			run itunibo.robot.resourceModelSupport.updateSonarRobotModel( myself, payloadArg(1) )
		}
	} 
    Goto  waitModelChange
    
	State changeModel{  
		printCurrentMessage 
		//ROBOT MOVE
		onMsg( modelChange : modelChange( robot,V ) ) { // V= w | ...
			run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
			emit local_modelChanged : modelChanged(  robot,  $payloadArg(1))  //for the robotmind
		} 
		//SONAR DATA  
		onMsg( modelChange : modelChange( sonarRobot,V ) ) { // V= w | ...
			run itunibo.robot.resourceModelSupport.updateSonarRobotModel( myself, payloadArg(1) )
		}
	}  
	Goto  waitModelChange
} 
 
 /*
  * --------------------------------------------------------
  * Basic robot: just an actuator of move commands
  * --------------------------------------------------------
  */
  QActor basicrobot context ctxMindSprint1 {	
	State s0 initial {  
  		solve( consult("basicRobotConfig.pl") )   
 		solve( robot(R, PORT) )  //R = virtual | realmbot | realnano
  		ifSolved {println( "USING ROBOT : ${getCurSol(\"R\")},  port= ${getCurSol(\"PORT\")} " )
  		} else {println("no robot")}
   		ifSolved {run itunibo.robot.robotSupport.create(myself, @R, @PORT )}
   		run itunibo.robot.robotSupport.move( "msg(a)" )
   		delay 700
   		run itunibo.robot.robotSupport.move( "msg(h)" )	//per non far slittare il robot
   		delay 150										//per non far slittare il robot
   		run itunibo.robot.robotSupport.move( "msg(d)" )
   		delay 700
   		run itunibo.robot.robotSupport.move( "msg(h)" )
 	}  
	Goto waitCmd   
 	 
	State waitCmd{  } //robotCmd comes from a console OUTSIDE this (sub)system
	Transition t0  whenMsg   robotCmd  -> handleRobotCmd
	
	State handleRobotCmd{ //does not handle alarms 
		//printCurrentMessage 
		onMsg( robotCmd : robotCmd( MOVE ) ) { //MOVE = w | a | s | d | h
			run itunibo.robot.robotSupport.move( "msg(${payloadArg(0)})" ) 
		}	
 	}  
	Goto waitCmd 
	
} 

  
