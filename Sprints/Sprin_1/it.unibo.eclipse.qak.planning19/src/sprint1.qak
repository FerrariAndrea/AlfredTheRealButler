/*
 * Sprint1 (TestPlan1)
 * 
 * Muove il robot virtuale
 * Usa il planner con mappa statica per trovare la strada verso il frigo e tronare indietro
*/
System sprint1
mqttBroker "localhost" : 1883  

Dispatch modelChange  : modelChange( TARGET, VALUE )   

Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Dispatch modelChange  : modelChange( TARGET, VALUE )  //force a resource-model change
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )  //sent by the mind
 
Dispatch askPlan  : askPlan(X,Y) 
  
 
Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 
Event  obstacle       : obstacle( DISTANCE )	     //from  sonar handler

Event  local_modelChanged   : modelChanged( TARGET, VALUE )

Context ctxMindSprint1   ip [host="localhost" port=8038]    -mqtt 


/*
 * resourcemodel viene modificato e di conseguenza BasicRobot
 */
ExternalQActor resourcemodel context ctxMindSprint1
QActor butler context ctxMindSprint1{
	["
		var BackTime   = 500L		
		var StepTime   = 330L	//for virtual
		var RotateTime = 300L	//for virtual
		var PauseTime  = 100L 
		var dest_x =7;
		var dest_y =9;
	"]	
		State s0 initial {	
		println("&&&  butler STARTED")
		solve( consult("sysRules.pl")	 )       
		solve( consult("floorMap.pl")	 )
		solve( showMap	 )
 	}Goto exploreTheRoom
	
	State exploreTheRoom{
		
	}
	Goto testPlan1
	
	
	State testPlan1{ 
		forward planner -m askPlan : askPlan( "$dest_x" ,"$dest_y")
		
 	}
	//Transition t0   whenMsg stepOk   -> hadleStepOk
	//				whenMsg stepFail -> hadleStepKo 
}

/*
 * 1) Waits for the message 'onestep' from the application layer
 * 2) Performs a single-step-ahead with the given time
 * 3) If all ok, sends the 'answer'  stepOk
 * 4) If finds an obstacle, sends the 'answer' stepFail(T) with T=time elapsed before obstacle
 */
 
QActor butlerstep context ctxMindSprint1 {
[" var foundObstacle = false; var StepTime = 0L"]  
	State s0 initial {	   
		["foundObstacle = false "]
	} 
	Transition t0 whenMsg onestep -> doMoveForward
	
	State doMoveForward{		  
		onMsg( onestep : onestep( TIME ) ) { 
			["StepTime = payloadArg(0).toLong(); println(StepTime)"]
			forward resourcemodel -m modelChange : modelChange(robot,w)
			run itunibo.planner.plannerUtil.startTimer()
		}
	} 
	Transition t0 whenTimeVar  StepTime   -> endDoMoveForward		
 		          whenEvent     obstacle  -> stepFail
		  
	State endDoMoveForward{
		forward resourcemodel -m modelChange : modelChange(robot,h)
		forward butler -m stepOk : stepOk(ok)  //answer
	}
	Goto s0
		
	State stepFail{
		run itunibo.planner.moveUtils.setDuration(myself)  //assert wduration/1
		println("&&& butlerstep stepfail ")
		solve( wduration( TIME ) )
		forward butler -m stepFail : stepFail(obstacle,#TIME)  	
	}
	Goto s0


}   


QActor planner context ctxMindSprint1{      
["  
var Curmove     = \"\"  
var IterCounter = 0
"]	
	State s0 initial {	 
		println("&&&  planex0 STARTED")
		run itunibo.planner.plannerUtil.initAI()
		println("INITIAL MAP") 
 		run itunibo.planner.plannerUtil.showMap() 
 	}
  	Transition t0 whenEvent  askPlan -> setGoal
  	
 	State setGoal{
 		onMsg( askPlan : askPlan( X,Y ) ) { 
 			["
				var x = payloadArg(0)
 				var y = payloadArg(1)
			"]
 			run itunibo.planner.plannerUtil.setGoal(x,y)
 		 	run itunibo.planner.moveUtils.doPlan( myself ) //moves stored in actor kb
	 	}
 	}Goto executePlannedActions  
     
    State executePlannedActions{ 
 		solve( retract( move(M) ) ) 	//consume a move
		ifSolved {   
			["Curmove = getCurSol(\"M\").toString()"]  
			run itunibo.planner.moveUtils.doPlannedMove(myself, Curmove)
		} else { ["Curmove=\"nomove\" "] 		} 
 
  	}  
	Goto executePlannedActions  if "(Curmove != \"nomove\")" else nextStep
 
 	State nextStep{
 		println("MAP after step $IterCounter")  
 		run itunibo.planner.plannerUtil.showMap() 
  		["IterCounter++"]
 	}
 	Goto endOfJob if "(IterCounter==2)" else donextStep 
 	
  	State donextStep{
  		run itunibo.planner.plannerUtil.setGoal("0","0")    
  		run itunibo.planner.moveUtils.doPlan( myself ) 
  	}
 	Goto executePlannedActions 
   	
	State endOfJob{
		println("FINAL MAP")  
 		run itunibo.planner.plannerUtil.showMap() 
		println("&&&  planex0 ENDS")
 	}
}	

 

/*
QActor resourcemodel context ctxMindSprint1{
["var dobackstep = false"]
	State s0 initial {		
		solve( consult("sysRules.pl")	 )       
		solve( consult("resourceModel.pl")	 )
		solve( showResourceModel ) 		
		run itunibo.coap.modelResourceCoap.create( myself, "resourcemodel" ) //CoAP access
	} 
	Goto waitModelChange
	 
	State waitModelChange{ }
	Transition t0 whenMsg modelChange -> changeModel
	              whenMsg modelUpdate -> updateModel

	State updateModel{  
		onMsg( modelUpdate : modelUpdate(robot,V ) ) {
			run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
		}
		onMsg( modelUpdate : modelUpdate(sonarRobot,V ) ) {
			run itunibo.robot.resourceModelSupport.updateSonarRobotModel( myself, payloadArg(1) )
		}
	} 
    Goto  waitModelChange
    
	State changeModel{  
		printCurrentMessage 
		//ROBOT MOVE
		onMsg( modelChange : modelChange( robot,V ) ) { // V= w | ...
			run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
			emit local_modelChanged : modelChanged(  robot,  $payloadArg(1))  //for the robotmind
		} 
		//SONAR DATA  
		onMsg( modelChange : modelChange( sonarRobot,V ) ) { // V= w | ...
			run itunibo.robot.resourceModelSupport.updateSonarRobotModel( myself, payloadArg(1) )
		}
	}  
	Goto  waitModelChange
} 
*/