System system3
mqttBroker "localhost" : 1883

Dispatch modelChange  : modelChange( TARGET, VALUE )  //force a resource-model change
Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time
Dispatch onerotationstep   : onerotationstep(MOVE)
Dispatch rotationOk        : rotationOk(STALL)

Dispatch goTo  : goTo( X,Y )
Dispatch goToOk  : goToOk( V )
Dispatch goToFail  : goToFail( V )

Dispatch modelRequest : modelRequest( TARGET,PROP)  
Dispatch modelMapResponse : modelMapResponse( X,Y ) 

//Macro dispatch
Dispatch addFood : addFood(X) //1 or 2: payload for now is ignored.
Dispatch prepare : prepare(X) //Non so perché senza Payload non mi funziona, quindi ne metto uno che viene ignorato. Idem per clear (Luca)
Dispatch clear : clear(X)
Dispatch home : home(X)
Dispatch missionFinish : missionFinish(X)//risposta

Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 


Event  collision     : collision(OBJECT)	     //from  sonar on robot 
Dispatch modelUpdateMap  : modelUpdateMap( NAME,X,Y )
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )
Dispatch onestepIW       : onestepIW(DURATION)//IgnoreWall (forse inutile)

Dispatch modelRobotResponse : modelRobotResponse( X,Y,O ) 

Dispatch doExplor : doExplor( TARGET )  
Dispatch endExplor : endExplor(V)

Context ctxExplorer ip[host="localhost" port=8039] -mqtt
Context ctxDummy ip[host="dummyhost" port=9999] -mqtt 

ExternalQActor kb context ctxDummy
ExternalQActor resourcemodel context ctxDummy
ExternalQActor onecellforward context ctxDummy
ExternalQActor onerotateforward context ctxDummy


QActor missionsolver context ctxExplorer{ 
	["	
	var addingFood = false
	var preparing = false
	var clearing = false
	var goingHome =false
	"]
	State s0 initial {	
		println("Actor: Mission Solver; State: initial")	
	}Goto waiting
	
	State waiting{
			println("Waiting for mission... Please send an action!") 	
	}	Transition t0 whenEvent	  addFood -> addingFood
				  whenEvent   prepare -> preparingRoom
				  whenEvent   clear -> clearingRoom
				  whenEvent   home -> home 
				  // ------------------ MACRO COMMANDS ------------------
	
	State addingFood {
		//SI DEVE AGGIUNGERE IL PAYLOAD, OVVERO SE SI AGGIUNGE IL TIPO 1 DI CIBO (PIZZA) OPPURE IL TIPO 2 (CRESCENTINA)
		//COSA FA QUESTO TASK?
		//SE IL CIBO E' PRESENTE NEL FRIGO, LO AGGIUNGE AL TAVOLO; IN CASO CONTRARIO, NOTIFICA IL MAITRE (ANCORA DA FARE)
		//RITORNA NELLA POSIZIONE HOME
		["storeCurrentMessageForReply()"]
		println("ADDING FOOD: Go to Fridge")
		["addingFood = true"]
	} Goto goToFridge
	
	State preparingRoom {
		["storeCurrentMessageForReply()"]
		println("PREPARING: Go to Pantry")
		["preparing = true"]
		//METTERE PIATTI DAL PANTRY AL TABLE
	} Goto goToPantry
	
	State clearingRoom {
		["storeCurrentMessageForReply()"]
		println("ADDING FOOD: Go to Table")
		["clearing = true"]
		//PRENDERE CIBO DAL TAVOLO, PORTARLO AL FRIGO E I PIATTI NEL DISHWASHER
	} Goto goToTable
	
	State home {
		["storeCurrentMessageForReply()"]
		println("ADDING FOOD: Go to Home")
		["	 addingFood = false
			 preparing = false
			 clearing = false
			 goingHome =true
		"]
	} Goto goToHome
	// ------------------ REACH OBJECTS ------------------
	
	State goToFridge {
		forward kb -m modelRequest : modelRequest(map,fridge)
	} Transition t0   whenMsg modelMapResponse  -> handlePos
	
	State goToPantry {
		["goingHome=false"]	
		forward kb -m modelRequest : modelRequest(map,pantry)
	} Transition t0   whenMsg modelMapResponse  -> handlePos
	
	State goToDishwasher {
		["goingHome=false; clearing=false"]	
		forward kb -m modelRequest : modelRequest(map,dishwasher)
	} Transition t0   whenMsg modelMapResponse  -> handlePos
	
	State goToTable {
		["addingFood=false;preparing=false"]	
		forward kb -m modelRequest : modelRequest(map,table)
	} Transition t0   whenMsg modelMapResponse  -> handlePos
	
	State goToHome {
		forward kb -m modelRequest : modelRequest(map,home)
	} Transition t0   whenMsg modelMapResponse  -> handlePos
	
 	State  handlePos{
 		["var X=0;var Y=0;"]
 		onMsg(   modelMapResponse:  modelMapResponse(X,Y) ) {			
			["X=payloadArg(0).toInt();Y=payloadArg(1).toInt()"]				
		}
		forward explorer -m goTo : goTo($X,$Y)
 	} Transition t0   whenMsg goToOk  -> goalOk
 					  whenMsg goToFail  -> fail
	
 	State fail{
 		println("Explorer: fail, return at home in 2s!")
 		delay 2000
 		//here send msg if you want see error msg on frontend 		
 	}Goto goToHome
 	
	State goalOk{		  
 		println("Explorer: on the target cell (simulate action 2s)!")
 		delay 2000 // to simulate the action
 	} Goto checkAddingFood
 	
 	State checkAddingFood {} Goto goToTable if "addingFood" else checkPreparingRoom
 	State checkPreparingRoom {} Goto goToTable if "preparing" else checkClearingRoom
 	State checkClearingRoom {} Goto goToDishwasher if "clearing" else checkGoingHome
 	State checkGoingHome {} Goto goToHome if "goingHome" else reply
 	
 	State reply{	["replyToCaller(\"missionFinish\", \"missionFinish(ok)\")"]	}Goto waiting
 	
}

QActor explorer context ctxExplorer{     
	["
	var stepCounter = 0 
	var Move = \"\"
	var StepTime :Int  = 350	//for virtual
	var RotateTime = 300L	//for virtual
	var PauseTime  = 250L 
	var Direction = \"\"
	//-------------------------------
	var mapEmpty    = false
	val mapname     = \"roomBoundary\" 
	var Tback       = 0
	var NumStep     = 0

	var secondLap : Boolean = false
	var mustStop : Boolean = false
	
	var needExploreBound : Boolean =false
	var tableFound : Boolean =false
	var directionSud : Boolean =false
	"]
	State s0 initial {
		
		println("Actor: Explorer; State: initial")		
	    solve( consult("moves.pl")	 )//forse da rimuovere
		run itunibo.coap.observer.resourceObserverCoapClient.create( "coap://localhost:5683/resourcemodel" )
 		run itunibo.planner.plannerUtil.initAI()
		run itunibo.planner.moveUtils.showCurrentRobotState()
		run itunibo.planner.plannerUtil.showMap()
	}Goto waitCmd
	//--------------------------------------------------------------EXPLORE BOUND AND TABLE
	State waitCmd{
		println("Waiting for exploration cmd...")
	}Transition t0 whenMsg doExplor -> handeCmd
				 whenEvent   goTo  -> goToPosition
		
	State handeCmd{
		["storeCurrentMessageForReply()"]
		["needExploreBound=false"]
		onMsg(   doExplor:  doExplor(TARGET) ) { 
			
			["
				needExploreBound = (payloadArg(0)==\"bound\")
				secondLap=false
			"]
		}//else explore for table 		
	}Goto exploreBounds if "needExploreBound" else exploreTale
	
	
	
	//----------------------------------------------------------------------------------------------------------exploreBounds
	State exploreBounds {				
		if "!secondLap"{
			println("Start explore bounds.")
			["NumStep=0"]
		}else{
			println("Second laps for explore bounds.")
		}		
	} 
	Goto rotateEast  if "secondLap" else detectPerimeter
	
	State rotateEast {
		["NumStep=0"]
		["Move=\"a\""]
		forward onerotateforward -m onerotationstep : onerotationstep(a)				
		run itunibo.planner.moveUtils.doPlannedMove(myself, Move)
			 		
	} Transition t0 whenMsg rotationOk -> detectPerimeter

	State detectPerimeter {		
		["NumStep++"]
  		run itunibo.planner.plannerUtil.showMap()  	
	} Goto goOneStepAhead if "(NumStep<5)" else perimeterWalked
	
	State goOneStepAhead {
   		run itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime, "onecellforward")
	} 
	Transition t0 whenMsg stepOk -> handleStepOk
				whenEvent collision -> checkingObject

	State handleStepOk {
		run itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
		delay 250
	} Goto goOneStepAhead
		  
	State checkingObject {
		onMsg(collision : collision(OBJECT)) {
			["val ObjName = payloadArg(0)"]
			println("OGGETTO IN COLLISIONE: $ObjName")
			if "(ObjName.equals(\"pantry\") || ObjName.equals(\"dishwasher\") || ObjName.equals(\"fridge\")|| ObjName.equals(\"table\"))" {
				["
				val XTemp = itunibo.planner.plannerUtil.getPosX()
				val YTemp = itunibo.planner.plannerUtil.getPosY()	
				tableFound	=ObjName.equals(\"table\")		
				"]
				forward kb -m modelUpdateMap : modelUpdateMap($ObjName, $XTemp,$YTemp)
				
			}
			
		}
	} Goto consumeStepFial if "needExploreBound" else consumeHandleStepFail
	
	State consumeStepFial{
		
	}Transition t0 whenMsg stepFail ->  handleStepFail	
	State consumeHandleStepFail{
		
	}Transition t0 whenMsg stepFail ->  handleStepFailTable
		
	State handleStepFail {
		delay 500
		["val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()"]
		forward resourcemodel -m modelUpdate : modelUpdate(roomMap, $MapStr)
		/*
		onMsg(stepFail : stepFail(Obs,Time)) {//probabilmente questo non va
			["Tback=payloadArg(1).toString().toInt() / 4"] //back just a little ..
 			println("stepFailed----> ${payloadArg(0).toString()}")
		}
		run itunibo.planner.moveUtils.backToCompensate(myself, Tback, Tback) 
		
		*/  		 
		run itunibo.planner.moveUtils.setObstacleOnCurrentDirection(myself)//test
		if "secondLap" {
			["Move=\"d\""]
			forward onerotateforward -m onerotationstep : onerotationstep(d)				
			run itunibo.planner.moveUtils.doPlannedMove(myself, Move)
		} else {
			run itunibo.planner.plannerUtil.wallFound()
			["Move=\"a\""]
			forward onerotateforward -m onerotationstep : onerotationstep(a)				
			run itunibo.planner.moveUtils.doPlannedMove(myself, Move)				
		}
	}Transition t0 whenMsg rotationOk -> detectPerimeter

	State perimeterWalked {
		if "!secondLap" {
			println("FINAL MAP")
			run itunibo.planner.moveUtils.showCurrentRobotState()
			run itunibo.planner.plannerUtil.saveMap(mapname)
			["secondLap = true"]
		} else {
			["mustStop = true"]
		}
	} Goto endOfJobBounds   if "mustStop" else  exploreBounds
	
	State endOfJobBounds {
		delay 500
		forward onerotateforward -m onerotationstep : onerotationstep(d)
			["Move=\"d\""]
		run itunibo.planner.moveUtils.doPlannedMove(myself,Move)
		["val D = \"down\""]
		run itunibo.planner.plannerUtil.autoResetRobotPos(0,0,D)
		println("Perimeter completely walked. Exit.")
	}Transition t0 whenMsg rotationOk ->  reply	
	
	State reply{
		["replyToCaller(\"endExplor\", \"endExplor(ok)\")"]	
	}Goto waitCmd
	//----------------------------------------------------------------------------------------------------------exploreTale
	State exploreTale{
		println("Start explore table.")
		["tableFound=false"]
	}Goto goOneStepAhead 
	

	State handleStepFailTable {
		["
		val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()
		"]
		forward resourcemodel -m modelUpdate : modelUpdate(roomMap, $MapStr)
		run itunibo.planner.plannerUtil.wallFound()
		
	} Goto endOfJobTable if "tableFound" else askOrientation
	
	State askOrientation{
		forward kb -m modelRequest : modelRequest(robot, location)
		
	}Transition t0 whenMsg modelRobotResponse ->  rotateBefore	
	
	State rotateBefore{
		onMsg(modelRobotResponse : modelRobotResponse(X,Y,O)) {
			["val actualOrientation = payloadArg(2)"]
			if "actualOrientation==\"sud\""{
				["Move=\"a\""]
				forward onerotateforward -m onerotationstep : onerotationstep(a)				
				run itunibo.planner.moveUtils.doPlannedMove(myself, Move)	
			}
			if "actualOrientation==\"nord\""{
				["Move=\"d\""]
				forward onerotateforward -m onerotationstep : onerotationstep(d)				
				run itunibo.planner.moveUtils.doPlannedMove(myself, Move)	
			}			
		}
	}Transition t0 whenMsg rotationOk -> moveOne
	
	State moveOne{
		delay 250
		run itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime, "onecellforward")
	} 
	Transition t0 whenMsg stepOk -> rotateAfter
				whenEvent collision -> checkingObject
				
	State rotateAfter{
			run itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
			delay 250
			if "Move==\"a\""{
				forward onerotateforward -m onerotationstep : onerotationstep(a)
			}else{
				forward onerotateforward -m onerotationstep : onerotationstep(d)
			}
			run itunibo.planner.moveUtils.doPlannedMove(myself, Move)			
	}Transition t0 whenMsg rotationOk -> goOneStepAhead
	
	State endOfJobTable {
		//QUI FORSE SERVE UN GO-TO-HOME
		println("Map after explore table")
		run itunibo.planner.plannerUtil.showMap()
		run itunibo.planner.plannerUtil.saveMap(mapname)//test
		println("Table exploration end.")
		["replyToCaller(\"endExplor\", \"endExplor(ok)\")"]	
	}Goto waitCmd
	//--------------------------------------------------------------EXPLORE GO TO 
 	
	State goToPosition{
	 	["storeCurrentMessageForReply()"]
	 	onMsg(   goTo:  goTo(X,Y) ) { 
			
			["
				var X = payloadArg(0).toInt()
				var Y = payloadArg(1).toInt()
				//var O = payloadArg(2)
			"]
				
		solve( direction(D) )   
   		println("Actor: Explorer; State: goToPosition; Payload: direction at start: ${getCurSol(\"D\").toString()}")
		run itunibo.planner.plannerUtil.showMap()		
		run itunibo.planner.plannerUtil.setGoal(X,Y)
		run itunibo.planner.moveUtils.doPlan( myself )
		}
 	}Goto executePlannedActions  if "itunibo.planner.moveUtils.existPlan()" else endOfJobOk 


	State executePlannedActions{ 
		
		//solve( showMoves ) 
		solve( retract( move(M) ) ) //consume a move
		ifSolved {  
			["Move = getCurSol(\"M\").toString()"]
		} else { ["Move = \"\""]  } 
 	}
	Goto doTheMove  if "(Move.length>0) " else endOfJobOk
 	
 	State doTheMove{
		if "Move==\"a\" || Move==\"d\" " {//ROTATION			
			forward onerotateforward -m onerotationstep : onerotationstep($Move)	
		} else{ // W			
			forward onecellforward -m onestep : onestep($StepTime)	
		}	
		
	}
	Transition t0   whenMsg stepOk   	-> handleStepOk   
					whenMsg stepFail 	-> endOfJobFail  
					whenMsg rotationOk 	-> handleStepOk
					//qui handleStop
	 	
	State handleStepOk{
		run itunibo.planner.moveUtils.doPlannedMove(myself, Move)	
		delayVar PauseTime	
	}
	Goto executePlannedActions
	

 	/*
	State goHome{
		println("Actor: Explorer; State: backToHome")
 		solve( direction(D) )
   		println("Actor: Explorer; State: backToHome; Payload: ${getCurSol(\"D\").toString()}")
 		println("Actor: Explorer; State: backToHome; Payload: MAP BEFORE backToHome")
		run itunibo.planner.plannerUtil.showMap()	
		solve( retractall( move(_) ))		//clean the actor kb
 		run itunibo.planner.plannerUtil.setGoal(0,0)
 		["goingHome=true"]
 		run itunibo.planner.moveUtils.doPlan( myself )
 		run itunibo.planner.moveUtils.existPlan() //is it necessary?
 	} 
	Goto executePlannedActions //doGoHomeActions 
	
	State atHome {  //reposition	
 		solve( direction(D) )
 		["Direction = getCurSol(\"D\").toString() "]
		println( @D ) 
		["
		val map = itunibo.planner.plannerUtil.getMap() 
		println(map)
		"] 		
   		println("Actor: Explorer; State: atHome; Payload: direction at home: ${getCurSol(\"D\").toString()}")
   	
	}
	Goto rotateSouth
	
	 */
	
	State rotateSouth{
		["Move=\"a\""]
		delayVar PauseTime //questo prima era uno StepTime
		forward onerotateforward -m onerotationstep : onerotationstep($Move)//
   		
	}Transition t0	whenMsg rotationOk 	-> checkSouth

	State checkSouth{
		run itunibo.planner.moveUtils.doPlannedMove(myself, Move)	
		solve( direction(D) )
		["Direction = getCurSol(\"D\").toString() "]
		println("Actor: Explorer; State: rotateSouth; Payload: $Direction")
	}
	Goto rotateSouth  if "(Direction!=\"downDir\")" else endOfJobOk
	
	State endOfJobOk{
		println("Explorer: on the target cell!")
		["replyToCaller(\"goToOk\", \"goToOk(ok)\")"]	
	} Goto waitCmd 
	
	State endOfJobFail{
		println("Actor: Explorer; State: handleStepFail; Payload: Fail step :(")
		run itunibo.planner.plannerUtil.showMap()	
		println("Actor: Explorer; State: handleStepFail; Payload: Replan and return at home.")
		["replyToCaller(\"goToFail\", \"goToFail(fail)\")"]	
	} Goto waitCmd 
}	
