System system7
mqttBroker "localhost" : 1883

Event  collision     : collision(OBJECT)	     //from  sonar on robot 
Dispatch modelUpdateMap  : modelUpdateMap( NAME,X,Y )
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )
Dispatch onestep       : onestep(DURATION)
Dispatch onestepIW       : onestepIW(DURATION)//IgnoreWall
Dispatch onerotationstep   : onerotationstep(MOVE)


Dispatch doExplor : doExplor( TARGET )  
Dispatch endExplor : endExplor(V)

Context ctxExplorerRoom ip[host="localhost" port=8039] -mqtt
Context ctxDummy ip[host="dummyhost" port=9999] -mqtt 

//Explore perimeter
ExternalQActor resourcemodel context ctxDummy
ExternalQActor onestepahead  context ctxDummy
ExternalQActor onecellforward context ctxDummy
ExternalQActor onerotateforward context ctxDummy
ExternalQActor kb context ctxDummy

QActor roomexplorer context ctxExplorerRoom {
	["
	var mapEmpty    = false
	val mapname     = \"roomBoundary\"  //\"roomMbot3\"		// 
	var Tback       = 0
	var NumStep     = 0
 
	//REAL ROBOT
	//var StepTime   = 1000	 
	//var PauseTime  = 500 

	//VIRTUAL ROBOT
	var StepTime   = 330	 
	var PauseTime  = 250
	var RotateTime = 300

	//OTHER
	var Move = \"\"
	//var PauseTimeL  = PauseTime.toLong()
	var secondLap : Boolean = false
	var mustStop : Boolean = false
	
	var needExploreBound : Boolean =false
	var tableFound : Boolean =false
	var directionSud : Boolean =false
"]
	State s0 initial {
		run itunibo.coap.observer.resourceObserverCoapClient.create( "coap://localhost:5683/resourcemodel" )
 		run itunibo.planner.plannerUtil.initAI()
		run itunibo.planner.moveUtils.showCurrentRobotState()
	}Goto waitCmd
	
	State waitCmd{
		
	}Transition t0 whenMsg doExplor -> handeCmd
		
	State handeCmd{
		["storeCurrentMessageForReply()"]
		["needExploreBound=false"]
		onMsg(   doExplor:  doExplor(TARGET) ) { 
			
			["
				needExploreBound = (payloadArg(0)==\"bound\")
			"]
		}//else explore for table 		
	}Goto exploreBounds if "needExploreBound" else exploreTale
	
	
	
	//----------------------------------------------------------------------------------------------------------exploreBounds
	State exploreBounds {		
		//If you want to start directly from secondLap (perimeter walked in the opposite way) flag this.
		//["secondLap=true"]
	} 
	Goto detectPerimeter if "secondLap == false" else rotateEast
	
	State rotateEast {
		["NumStep=0"]
		run itunibo.planner.moveUtils.rotateLeft90( myself )//si potrebbe sostituire con il nostro onerotate	
	} Goto detectPerimeter
	
	State detectPerimeter {
		["NumStep++"]
      	//NO GOAL : JUST ONE STEP ahead
  		run itunibo.planner.plannerUtil.showMap()  	
	} Goto goOneStepAhead if "(NumStep<5)" else perimeterWalked
	
	State goOneStepAhead {
		//printCurrentMessage
   		run itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime, "onecellforward")
	} 
	Transition t0 whenMsg stepOk -> handleStepOk
				//whenMsg stepFail -> handleStepFail
				whenEvent collision -> checkingObject

	State handleStepOk {
		run itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
		delay 500
	} Goto goOneStepAhead

	//Per intercettare l'evento di collisione
	//State preCheckingObject {} Transition t0 whenEvent collision -> checkingObject
					  
	State checkingObject {
		onMsg(collision : collision(OBJECT)) {
			["val ObjName = payloadArg(0)"]
			println("OGGETTO IN COLLISIONE: $ObjName")
			if "(ObjName.equals(\"pantry\") || ObjName.equals(\"dishwasher\") || ObjName.equals(\"fridge\")|| ObjName.equals(\"table\"))" {
				["
				val XTemp = itunibo.planner.plannerUtil.getPosX()
				val YTemp = itunibo.planner.plannerUtil.getPosY()	
				tableFound	=ObjName.equals(\"table\")		
				"]
				forward kb -m modelUpdateMap : modelUpdateMap($ObjName, $XTemp,$YTemp)
				
			}
			
		}
	} Goto handleStepFail if "needExploreBound" else handleStepFailTable
	
	State handleStepFail {
		//println("&&& Found Wall")
		["
		val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()
		//println(\"MapStr:\"+MapStr)
		"]
		forward resourcemodel -m modelUpdate : modelUpdate(roomMap, $MapStr)
		/*
		onMsg(stepFail : stepFail(Obs,Time)) {//probabilmente questo non va
			["Tback=payloadArg(1).toString().toInt() / 4"] //back just a little ..
 			println("stepFailed----> ${payloadArg(0).toString()}")
		}
		run itunibo.planner.moveUtils.backToCompensate(myself, Tback, Tback) 
		
		*/  
		run itunibo.planner.plannerUtil.wallFound()
		if "secondLap == false" {
			run itunibo.planner.moveUtils.rotateLeft90( myself ) //si potrebbe sostituire con il nostro onerotate
		} else {
			run itunibo.planner.moveUtils.rotateRight90( myself )		//si potrebbe sostituire con il nostro onerotate	
		}
		delay 1000 //necessario per una corretta rotazione
		//run itunibo.planner.moveUtils.doPlannedMove(myself, "l")
		
	} Goto detectPerimeter

	State perimeterWalked {
		if "secondLap == false" {
			println("FINAL MAP")
			run itunibo.planner.moveUtils.showCurrentRobotState()
			run itunibo.planner.plannerUtil.saveMap(mapname)
			["secondLap = true"]
		} else {
			["mustStop = true"]
		}
	} Goto exploreBounds if "mustStop == false" else endOfJobBounds
	
	State endOfJobBounds {
		run itunibo.planner.moveUtils.rotateRight90( myself )
		println("Perimeter completely walked. Exit.")
		["replyToCaller(\"endExplor\", \"endExplor(ok)\")"]	
	}Goto waitCmd
	
	//----------------------------------------------------------------------------------------------------------exploreTale
	State exploreTale{
		["tableFound=false"]
	}Goto goOneStepAhead 
	

	
	State handleStepFailTable {
		["
		val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()
		"]
		forward resourcemodel -m modelUpdate : modelUpdate(roomMap, $MapStr)
		run itunibo.planner.plannerUtil.wallFound()
		
	} Goto rotate if "(!tableFound)" else endOfJobTable
	State rotate{
		
	}Goto goOneStepAhead
	State endOfJobTable {
		//QUI FORSE SERVE UN GO-TO-HOME
		println("Table exploration end.")
		["replyToCaller(\"endExplor\", \"endExplor(ok)\")"]	
	}Goto waitCmd
}