/* Generated by AN DISI Unibo */ 
package it.unibo.onecellforward

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Onecellforward ( name: String, scope: CoroutineScope ) : ActorBasicFsm( name, scope){
 	
	override fun getInitialState() : String{
		return "s0"
	}
		
	override fun getBody() : (ActorBasicFsm.() -> Unit){
			
				var BackTrakingDistance :Int=0	//la distanza prima dello step per il backtraking
				var StepCm : Int =0			//vado in avanti di tot cm
				var ActualDistance :Int =0 	//cm attuali dal muro
				var NeedToBe : Int =0 			//cm che saranno dal muro dopo lo step
				var FoundObstacle =false		//trovato muro
				var MoveDone =false				//mossa onestep fatta
				var End =false					//usata in varie Transition
		
				val CoefSpeed :Long =4			//rapporto cm mancanti tempo movimento
				val ErrorePreCheck:Long =10		//cm mancanti dal muro concessi
				val ErroreConcesso :Long=2		//errore mi misura
				val MinDistanceWall : Long=2	//distanza minima dal muro
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						println("Start onecellforward")
					}
					 transition( edgeName="goto",targetState="ready", cond=doswitch() )
				}	 
				state("ready") { //this:State
					action { //it:State
					}
					 transition(edgeName="t026",targetState="checkFirst",cond=whenDispatch("onestep"))
				}	 
				state("checkFirst") { //this:State
					action { //it:State
						
									storeCurrentMessageForReply()
									FoundObstacle = false 
						if( checkMsgContent( Term.createTerm("onestep(DURATION)"), Term.createTerm("onestep(TIME)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								StepCm = payloadArg(0).toInt()
						}
						println("------------>StepCm[$StepCm]")
					}
					 transition(edgeName="t027",targetState="waitingForcheckFirstSonar",cond=whenEvent("sonarRobot"))
				}	 
				state("waitingForcheckFirstSonar") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("sonar(DISTANCE)"), Term.createTerm("sonar(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								
												ActualDistance = Integer.parseInt( payloadArg(0) ) 
												BackTrakingDistance = ActualDistance
												NeedToBe = ActualDistance-StepCm
								            	FoundObstacle = (NeedToBe+ErrorePreCheck<0) 				
								if(FoundObstacle){ replyToCaller("stepFail", "stepFail(obstacle,$ActualDistance) ")
								println("Actor: OneStepForward; State:cantDoOneStep")
								 }
								else
								 { println("Actor: OneStepForward; State: OK-> $NeedToBe")
								  }
						}
					}
					 transition( edgeName="goto",targetState="ready", cond=doswitchGuarded({FoundObstacle}) )
					transition( edgeName="goto",targetState="doMiniMoveForward", cond=doswitchGuarded({! FoundObstacle}) )
				}	 
				state("doMiniMoveForward") { //this:State
					action { //it:State
						forward("modelChange", "modelChange(robot,w)" ,"resourcemodel" ) 
						val ActualDelayTime =(ActualDistance-NeedToBe)*CoefSpeed
						stateTimer = TimerActor("timer_doMiniMoveForward", 
							scope, context!!, "local_tout_onecellforward_doMiniMoveForward", ActualDelayTime )
					}
					 transition(edgeName="t028",targetState="waitingForSonarW",cond=whenTimeout("local_tout_onecellforward_doMiniMoveForward"))   
					transition(edgeName="t029",targetState="checkSonarW",cond=whenEvent("sonarRobot"))
				}	 
				state("waitingForSonarW") { //this:State
					action { //it:State
						forward("modelChange", "modelChange(robot,h)" ,"resourcemodel" ) 
					}
					 transition(edgeName="t030",targetState="checkSonarW",cond=whenEvent("sonarRobot"))
				}	 
				state("checkSonarW") { //this:State
					action { //it:State
						forward("modelChange", "modelChange(robot,h)" ,"resourcemodel" ) 
						if( checkMsgContent( Term.createTerm("sonar(DISTANCE)"), Term.createTerm("sonar(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								
												ActualDistance = Integer.parseInt( payloadArg(0) )
												MoveDone= Math.abs(ActualDistance-NeedToBe)<ErroreConcesso
												End = MoveDone || ActualDistance<MinDistanceWall
								println("$ActualDistance ----> $NeedToBe")
						}
					}
					 transition( edgeName="goto",targetState="endStep", cond=doswitchGuarded({End}) )
					transition( edgeName="goto",targetState="doMiniMoveForward", cond=doswitchGuarded({! End}) )
				}	 
				state("endStep") { //this:State
					action { //it:State
						if(ActualDistance<MinDistanceWall){ NeedToBe=BackTrakingDistance;End=false;
						 }
						else
						 { forward("modelUpdate", "modelUpdate(robot,w)" ,"kb" ) 
						 End=true
						  }
					}
					 transition( edgeName="goto",targetState="endCorrezioneRotta", cond=doswitchGuarded({End}) )
					transition( edgeName="goto",targetState="goBackFromFail", cond=doswitchGuarded({! End}) )
				}	 
				state("correggiRotta") { //this:State
					action { //it:State
						forward("onerotationstep", "onerotationstep(Z)" ,"onerotateforward" ) 
					}
					 transition(edgeName="t031",targetState="endCorrezioneRotta",cond=whenEvent("rotationOk"))
				}	 
				state("endCorrezioneRotta") { //this:State
					action { //it:State
						val Err =Math.abs(ActualDistance-NeedToBe)
						replyToCaller("stepOk", "stepOk($Err)")
					}
					 transition( edgeName="goto",targetState="ready", cond=doswitch() )
				}	 
				state("goBackFromFail") { //this:State
					action { //it:State
						forward("modelChange", "modelChange(robot,s)" ,"resourcemodel" ) 
						val ActualDelayTime =(NeedToBe-ActualDistance)*CoefSpeed
						stateTimer = TimerActor("timer_goBackFromFail", 
							scope, context!!, "local_tout_onecellforward_goBackFromFail", ActualDelayTime )
					}
					 transition(edgeName="t032",targetState="waitingForSonarS",cond=whenTimeout("local_tout_onecellforward_goBackFromFail"))   
					transition(edgeName="t033",targetState="checkSonarS",cond=whenEvent("sonarRobot"))
				}	 
				state("waitingForSonarS") { //this:State
					action { //it:State
						forward("modelChange", "modelChange(robot,h)" ,"resourcemodel" ) 
					}
					 transition(edgeName="t034",targetState="checkSonarS",cond=whenEvent("sonarRobot"))
				}	 
				state("checkSonarS") { //this:State
					action { //it:State
						forward("modelChange", "modelChange(robot,h)" ,"resourcemodel" ) 
						if( checkMsgContent( Term.createTerm("sonar(DISTANCE)"), Term.createTerm("sonar(DISTANCE)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								
												ActualDistance = Integer.parseInt( payloadArg(0) )
												MoveDone= Math.abs(ActualDistance-NeedToBe)<ErroreConcesso
						}
					}
					 transition( edgeName="goto",targetState="stepFail", cond=doswitchGuarded({MoveDone}) )
					transition( edgeName="goto",targetState="goBackFromFail", cond=doswitchGuarded({! MoveDone}) )
				}	 
				state("stepFail") { //this:State
					action { //it:State
						val Err =Math.abs(ActualDistance-NeedToBe)
						replyToCaller("stepFail", "stepFail(obstacle,$Err) ")
					}
					 transition( edgeName="goto",targetState="ready", cond=doswitch() )
				}	 
			}
		}
}
