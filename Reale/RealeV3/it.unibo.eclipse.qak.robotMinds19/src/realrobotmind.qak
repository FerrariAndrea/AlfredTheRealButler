System systemreal
mqttBroker "192.168.43.61" : 1883

Event  envCond        : envCond( CONDTYPE )        //from the environment 
Event  sonarRobot     : sonar( DISTANCE )	     //from  sonar on robot 
Event  sonar          : sonar(SONAR, DISTANCE)	 //from sonar in the robot environment          
Event  polar          : p( Distance, Angle ) 

//my sonars (abilitati nel file kotlin "nanoSupport.kt riga 30")
Event  sonarLeft     : sonar( DISTANCE )
Event  sonarRigth     : sonar( DISTANCE )
Event  sonarBelancer    : sonar( DIFFERENCE )

Dispatch onestep       : onestep(DURATION)
Dispatch stepOk        : stepOk(V)		//TODO eliminate  V
Dispatch stepFail      : stepFail(R,T) //R=ok | obstacle, T = time

Dispatch setTimer        : setTimer(DURATION)		//TODO eliminate  V
Dispatch resetTimer      : resetTimer(V) //TODO eliminate  V
Dispatch tickTimer        : tickTimer(V) //TODO eliminate  V

Dispatch local_modelChanged   : modelChanged( TARGET, VALUE )
Dispatch robotCmd     : robotCmd( CMD )				  //sent by the mind to the basicrobot

Dispatch modelChange  : modelChange( TARGET, VALUE )  //force a resource-model change
Dispatch modelUpdate  : modelUpdate( TARGET, VALUE )  //sent by the mind

Dispatch internalReq : internalReq( TARGET )
Dispatch lastSonarRobot : lastSonarRobot( DISATNCE )

Context ctxRobot ip[host="localhost" port=8038] -mqtt
Context ctxDummy ip[host="dummyhost" port=9999] -mqtt //as ctdResourceModel and ctxMaitre

ExternalQActor resourcemodel context ctxDummy
ExternalQActor maitre context ctxDummy

QActor mindrobot context ctxRobot{
	["
	var obstacle = false
	val minDifferenceForBelance = 2
	var myagain = false
	"]
	
	State s0 initial {
		println("Start mindrobot")		
	}
	
	Goto waitCmd
	 
	State waitCmd {		} 
	Transition t0 whenEvent envCond      -> handleEnvCond
		       //   whenEvent sonarRobot   -> handleSonarRobot
		          whenEvent local_modelChanged -> handleModelChanged
	
	State handleEnvCond {
		printCurrentMessage
 		onMsg( envCond : envCond(CMD) ) {
 			forward basicrobot -m robotCmd : robotCmd( h )	//First do ...
 			forward resourcemodel -m modelUpdate : modelUpdate(robot,h) //... then update the model
		}
		
	}
	Goto waitCmd
	
	State requestBelancer{
		println("requestBelancer")
		//run itunibo.robotRaspOnly.sonarBelancerOnlySupport.requestValue()
	}
	Goto waitCmd
	/*
	//Transition t0 whenEvent sonarBelancer ->  riadrizza
	
	State riadrizza{
		
		["myagain = false"]
		onMsg ( sonarBelancer : sonar( DIFFERENCE ) ){
			["
				var diff = Integer.parseInt( payloadArg(0) )								
			"]
			println("riadrizza--> $diff")
			if "diff>2" {
				["myagain = true"]
				forward basicrobot -m robotCmd : robotCmd( a )			
				delay 50
				forward basicrobot -m robotCmd : robotCmd( h )
			}
			if "diff<-minDifferenceForBelance" {
				["myagain = true"]
				forward basicrobot -m robotCmd : robotCmd( d )	
				delay 50
				forward basicrobot -m robotCmd : robotCmd( h )
			}
 		}//onMsg
	}
	Goto waitCmd if "myagain" else requestBelancer
	
	State handleSonarRobot {
		printCurrentMessage
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){
			["obstacle = Integer.parseInt( payloadArg(0) ) < 20 "]
 		}//onMsg 	 
	}
	Goto waitCmd
	* 
	*/
	
	State handleModelChanged {
		printCurrentMessage
		onMsg ( local_modelChanged : modelChanged(robot,CMD) ){ 
			forward basicrobot -m robotCmd : robotCmd( $payloadArg(1) )	
			forward resourcemodel -m modelUpdate : modelUpdate(robot,$payloadArg(1)) //... then update the model
				
		}	
	}
	Goto waitCmd


}

QActor basicrobot context ctxRobot{
	State s0 initial {
		println("Start basicrobot")
		solve( consult("basicRobotConfig.pl") )   
 		solve( robot(R, PORT) )  //R = virtual | realmbot | realnano
  		ifSolved {println( "USING ROBOT : ${getCurSol(\"R\")},  port= ${getCurSol(\"PORT\")} " )}
  		else {println("no robot")}
  		ifSolved {run itunibo.robot.robotSupport.create(myself, @R, @PORT )}
	}
	Goto waitCmd
	
	State waitCmd{  } //robotCmd comes from a console OUTSIDE this (sub)system
	Transition t0  whenMsg   robotCmd  -> handleRobotCmd
	
	State handleRobotCmd{ //does not handle alarms 
		//printCurrentMessage 
		onMsg( robotCmd : robotCmd( MOVE ) ) { 
			//MOVE = w | a | s | d | h
			run itunibo.robot.robotSupport.move( "msg(${payloadArg(0)})" ) 
			}			
		}
	Goto waitCmd 
}

QActor sonarhandler context ctxRobot {


	["var LastSonarRobot : Int = 0"]
	State s0 initial {
		println("Start Sonarhandler")		
	}
	Transition t0 whenEvent sonarRobot ->  handleSonar
   				


     
 	State handleSonar {                      
 	//	printCurrentMessage  
 	//---------------------------------------------------------------SONAR OGGETTI VIRTUALI                                      
 	//	onMsg ( sonar  : sonar( SONAR, DISTANCE ) ){    			
	//	[" val D = Integer.parseInt( payloadArg(1) ) * 5"] //AMPLIFY
	//		emit polar : p( $D, 90  )  
 	//	}
 	//---------------------------------------------------------------SONAR FRONTALE  
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){     
	//	[" val D = Integer.parseInt( payloadArg(0) ) * 5"] //AMPLIFY
	//		emit polar : p( $D, 180  ) 
			forward resourcemodel -m modelChange : modelChange(sonarRobot,$payloadArg(0))
 			["LastSonarRobot =  Integer.parseInt( payloadArg(0) )"] 	
 			//println("lastsonarrobot--> $LastSonarRobot")		
 		}
 		//---------------------------------------------------------------SONAR Left
 		onMsg ( sonarLeft : sonar( DISTANCE ) ){     
	//	[" val D = Integer.parseInt( payloadArg(0) ) * 5"] //AMPLIFY
	//		emit polar : p( $D, 90  ) 
			forward resourcemodel -m modelChange : modelChange(sonarLeft,$payloadArg(0))
 		}
 		//---------------------------------------------------------------SONAR Rigth
 		onMsg ( sonarRigth : sonar( DISTANCE ) ){     
	//	[" val D = Integer.parseInt( payloadArg(0) ) * 5"] //AMPLIFY
	//		emit polar : p( $D, 270  ) 
			forward resourcemodel -m modelChange : modelChange(sonarRigth,$payloadArg(0))
 		}
 		//per il dispatch interno dell'ultimo sonar
 		onMsg ( internalReq : internalReq( TARGET ) ){     
	//	[" val D = Integer.parseInt( payloadArg(0) ) * 5"] //AMPLIFY
	//		emit polar : p( $D, 270  ) 
			forward onecellforward -m lastSonarRobot : lastSonarRobot( $LastSonarRobot )
 		}
 	} 
 	Transition t0 whenEvent sonar      ->  handleSonar
   	              whenEvent sonarRobot ->  handleSonar
   	              whenEvent sonarLeft ->  handleSonar
   	              whenEvent sonarRigth ->  handleSonar
   	               whenEvent internalReq ->  handleSonar
}


//Application move step
QActor onecellforward context ctxRobot {
	["
		var FoundObstacle = false
		var StepTime = 0L
		var Duration : Int =0
		var DistanzaMinima :Int =20
	"]  
	State s0 initial {	   
		["FoundObstacle = false "]
	} 
	Transition t0 whenMsg onestep -> checkFirst
	
	
	State checkFirst{
		["storeCurrentMessageForReply()"]		
		onMsg( onestep : onestep( TIME ) ) {
			["StepTime = payloadArg(0).toLong()"]
		}
		forward sonarhandler -m internalReq : internalReq(lastSonarRobot)
			
	}Transition t0 whenEvent lastSonarRobot  -> waitingForcheckFirstSonar
	
	State waitingForcheckFirstSonar{
		onMsg ( lastSonarRobot : lastSonarRobot( DISTANCE ) ){     
			["var distance = Integer.parseInt( payloadArg(0) ) 
              FoundObstacle = (distance<DistanzaMinima/4) "] 
               if"FoundObstacle"{
              	  ["replyToCaller(\"stepFail\", \"stepFail(obstacle,$distance) \")"]
				println("Actor: OneStepForward; State:cantDoOneStep")	
              }
   		}
	}Goto s0 if "FoundObstacle" else doMoveForward

	State doMoveForward{		  
		
			//["startTimer()"] <<<<<-----------------NON VA
			forward mindrobot -m local_modelChanged : modelChanged(robot, w)
			forward timer -m setTimer : setTimer( $StepTime )			
			run itunibo.planner.plannerUtil.startTimer()
		
	} 
	Transition t0
		whenEvent tickTimer  -> endDoMoveForward	
		whenEvent sonarRobot  -> handleSonarRobot	
		
 		          
		  
	State endDoMoveForward{
		forward mindrobot -m local_modelChanged : modelChanged(robot,h)
		["replyToCaller(\"stepOk\", \"stepOk(ok)\")"]	
		
	}
	Goto s0
	
	//Substitute with an ad-hoc actor for a real robot
	State handleSonarRobot{  //before than the step time
		printCurrentMessage
		run itunibo.planner.moveUtils.setDuration(myself)
 		onMsg ( sonarRobot : sonar( DISTANCE ) ){     
			["val distance = Integer.parseInt( payloadArg(0) ) 
              FoundObstacle = (distance<DistanzaMinima) "]  
              println("SONAR------>$distance")
   		}
	}	
	Goto stepFail if "FoundObstacle" else mustGoOn
	
	State stepFail{
		forward timer -m resetTimer : resetTimer( reset )						
		forward mindrobot -m local_modelChanged : modelChanged(robot,h)	
		solve( wduration( TIME ) )
		//["Duration=getDuration()"]
		println("Actor: OneStepForward; State:stepfail -> #TIME")			 
		["replyToCaller(\"stepFail\", \"stepFail(obstacle,#TIME) \")"]//#TIME
			 	
	}
	Goto s0
	
	State mustGoOn{
	}
	Transition t0 whenEvent tickTimer  -> endDoMoveForward	
					whenEvent sonarRobot  -> handleSonarRobot	
}

QActor timer context ctxRobot {
	["var ActualTimer = 0L "]
	State s0 initial {	   
		["ActualTimer = 0L "]
	}Transition t0 whenMsg setTimer -> start
	
	State start{
		onMsg( setTimer : setTimer( DURATION ) ) {
			["ActualTimer = payloadArg(0).toLong()"]
		}
	}Transition t0 whenTimeVar  ActualTimer -> drinnn	
					whenEvent resetTimer  -> s0
					
	State drinnn{
		forward onecellforward -m tickTimer : tickTimer(ok) 
	}
	Goto s0
	
}

QActor leds context ctxRobot {
	State s0 initial {	   
		run surpluss.ledManagerSupport.create()
		delay 10
		run surpluss.ledManagerSupport.frontLedBlink(250)
	}

}
